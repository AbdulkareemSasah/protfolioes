---
interface Stat {
    number: string;
    label: string;
    suffix?: string;
}

interface Props {
    heading?: string;
    stats: Stat[];
    backgroundColor?: "primary" | "secondary" | "transparent";
}

const { heading, stats = [], backgroundColor = "primary" } = Astro.props;

const bgClasses: Record<string, string> = {
    primary: "bg-primary",
    secondary: "bg-secondary",
    transparent: "bg-transparent",
};
---

<section class={`stats-section section ${bgClasses[backgroundColor]}`}>
    <div class="container">
        {heading && <h2 class="stats-heading">{heading}</h2>}

        <div class="stats-grid" data-stats>
            {
                stats.map((stat, index) => (
                    <div
                        class="stat-item"
                        style={`animation-delay: ${index * 0.1}s`}
                    >
                        <div class="stat-number">
                            <span class="stat-value" data-target={stat.number}>
                                {stat.number}
                            </span>
                            {stat.suffix && (
                                <span class="stat-suffix">{stat.suffix}</span>
                            )}
                        </div>
                        <p class="stat-label">{stat.label}</p>
                    </div>
                ))
            }
        </div>
    </div>
</section>

<style>
    .stats-section {
        position: relative;
        overflow: hidden;
    }

    .bg-primary {
        background: linear-gradient(
            135deg,
            var(--color-primary) 0%,
            var(--color-secondary) 100%
        );
    }

    .bg-secondary {
        background: var(--color-surface);
    }

    .bg-transparent {
        background: transparent;
    }

    .stats-heading {
        text-align: center;
        margin-bottom: 3rem;
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 2rem;
    }

    .stat-item {
        text-align: center;
        padding: 2rem;
        background: rgba(255, 255, 255, 0.03);
        border-radius: var(--radius-lg);
        border: 1px solid rgba(255, 255, 255, 0.05);
        transition: all 0.4s ease;
        opacity: 0;
        transform: translateY(20px);
        animation: fadeInUp 0.6s ease forwards;
    }

    .stat-item:hover {
        transform: translateY(-5px);
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--color-accent);
    }

    .stat-number {
        display: flex;
        align-items: baseline;
        justify-content: center;
        gap: 0.25rem;
        margin-bottom: 0.5rem;
    }

    .stat-value {
        font-family: var(--font-heading);
        font-size: clamp(2.5rem, 5vw, 4rem);
        font-weight: 800;
        background: linear-gradient(
            135deg,
            var(--color-accent) 0%,
            var(--color-text) 100%
        );
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
        line-height: 1;
    }

    .stat-suffix {
        font-family: var(--font-heading);
        font-size: clamp(1.5rem, 3vw, 2rem);
        font-weight: 700;
        color: var(--color-accent);
    }

    .stat-label {
        font-size: 1rem;
        color: var(--color-text-muted);
        margin: 0;
    }

    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(20px);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @media (max-width: 768px) {
        .stats-grid {
            grid-template-columns: repeat(2, 1fr);
        }

        .stat-item {
            padding: 1.5rem;
        }
    }
</style>

<script>
    // Counter animation
    const observerOptions = {
        threshold: 0.5,
        rootMargin: "0px",
    };

    const animateCounter = (element: Element, target: string) => {
        const numericValue = parseInt(target.replace(/\D/g, ""), 10);
        if (isNaN(numericValue)) {
            element.textContent = target;
            return;
        }

        const duration = 2000;
        const startTime = performance.now();

        const updateCounter = (currentTime: number) => {
            const elapsed = currentTime - startTime;
            const progress = Math.min(elapsed / duration, 1);
            const easeOutQuart = 1 - Math.pow(1 - progress, 4);
            const current = Math.round(easeOutQuart * numericValue);

            element.textContent = current.toString();

            if (progress < 1) {
                requestAnimationFrame(updateCounter);
            } else {
                element.textContent = target;
            }
        };

        requestAnimationFrame(updateCounter);
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
            if (entry.isIntersecting) {
                const statValues = entry.target.querySelectorAll(".stat-value");
                statValues.forEach((stat) => {
                    const target = stat.getAttribute("data-target");
                    if (target) {
                        animateCounter(stat, target);
                    }
                });
                observer.unobserve(entry.target);
            }
        });
    }, observerOptions);

    document.querySelectorAll("[data-stats]").forEach((section) => {
        observer.observe(section);
    });
</script>
